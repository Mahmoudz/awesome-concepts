<!-- markdownlint-disable -->

<!-- Welcome Message Animation -->
[![Typing SVG](https://readme-typing-svg.herokuapp.com?font=Fira+Code&size=35&pause=2000&color=555555&center=true&vCenter=true&random=false&width=800&height=100&lines=Welcome+To+Awesome+Concepts!)](https://git.io/typing-svg)

# Awesome Concepts

A curated collection of awesome technical concepts in the world of software engineering, explained in a concise and user-friendly manner. Whether you're a beginner or an expert engineer, this resource is designed to facilitate your grasp of a wide range of technical concepts.

## Table of Contents

Core:

- [Programming Fundamentals](#programming-fundamentals)
- [Algorithms & Data Structures](#algorithms-data-structures)
- [Software Design](#software-design)

Infra:

- [Infrastructure](#infrastructure)
- [DevOps & SRE](#devops-sre)
- [Network Security](#network-security)

Back:

- [System Architecture](#system-architecture)
- [Databases](#databases)
- [Backend](#backend)
- [Information Security](#information-security)

Front:

- [UI / UX](#ui-ux)
- [Web Frontend](#web-frontend)
- [Mobile Development](#mobile)
- [Desktop Development](#desktop)
- [Games Development](#games)
- [VR / AR](#vr-ar)

Data:

- [Data Science](#data-science)
- [AI](#ai)
- [Machine Learning](#machine-learning)
- [Deep Learning](#deep-learning)

Misc:

- [Blockchain](#blockchain)
- [Emerging Technologies](#emerging-technologies)

---

![Divider](.github/assets/divider-1.jpg)

### âž¤ Core

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Programming Fundamentals

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>IDE (Integrated Development Environment)</strong></summary>
    An IDE is a software application that provides tools and features for software development, including code editing, debugging, and project management.
</details>

<details>
    <summary><strong>Version Control</strong></summary>
    Version Control is a system that tracks changes to files and code over time, allowing multiple developers to collaborate, revert to previous versions, and manage code history.
</details>

<details>
    <summary><strong>Variables</strong></summary>
    Variables are symbols that represent values or data in programming. They are used to store and manipulate information within a program.
</details>

<details>
    <summary><strong>Function / Method</strong></summary>
    A Function (or Method) is a reusable block of code that performs a specific task or operation. It promotes code modularity and reusability.
</details>

<details>
    <summary><strong>Class</strong></summary>
    A Class is a blueprint or template for creating objects in object-oriented programming (OOP). It defines the structure and behavior of objects.
</details>

<details>
    <summary><strong>Error</strong></summary>
    An Error in programming refers to a mistake or issue that prevents a program from running correctly. Errors can be syntax errors, runtime errors, or logical errors.
</details>

<details>
    <summary><strong>Exception</strong></summary>
    An Exception is an event that disrupts the normal flow of a program. It is used to handle errors and exceptional conditions gracefully.
</details>

<details>
    <summary><strong>Storage</strong></summary>
    Storage refers to the devices and media used to store data in a computer system, such as hard drives, solid-state drives (SSDs), and cloud storage.
</details>

<details>
    <summary><strong>Memory</strong></summary>
    Memory, in computing, is used to temporarily store data and instructions that the CPU (Central Processing Unit) actively uses during program execution.
</details>

<details>
    <summary><strong>Disk</strong></summary>
    A Disk is a storage device that stores data on a physical medium, such as a hard disk drive (HDD) or solid-state drive (SSD). It provides long-term data storage and access for computers and other electronic devices.
</details>

<details>
    <summary><strong>Processor</strong></summary>
    A Processor (or CPU) is the central unit of a computer that performs arithmetic and logical operations. It executes instructions and manages data processing.
</details>

<details>
    <summary><strong>Thread</strong></summary>
    A Thread is the smallest unit of a process in a multitasking operating system. It allows for concurrent execution of tasks and improves program efficiency.
</details>

<details>
    <summary><strong>Process</strong></summary>
    A Process is an independent program or task running on a computer. It has its own memory space and resources and can execute multiple threads.
</details>

<details>
    <summary><strong>API (Application Programming Interface)</strong></summary>
    An API is a set of rules and protocols that allows different software applications to communicate and interact with each other. It defines the methods and data formats for requesting and exchanging information between systems.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Software Design

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Object-Oriented Programming (OOP)</strong></summary>
    Object-Oriented Programming (OOP) is a programming paradigm that uses objects and classes to structure code. It promotes modularity, reusability, and a clear organization of code.
</details>

<details>
    <summary><strong>Inheritance</strong></summary>
    Inheritance is a concept in OOP where a class can inherit properties and behaviors from another class. It promotes code reuse and hierarchy in class relationships.
</details>

<details>
    <summary><strong>Polymorphism</strong></summary>
    Polymorphism is a design principle in OOP where objects of different classes can be treated as objects of a common superclass. It allows for flexibility and dynamic behavior based on the actual object's type.
</details>

<details>
    <summary><strong>Composition</strong></summary>
    Composition is a design principle in OOP where objects of one class can be composed of objects of another class. It promotes building complex objects by combining simpler ones.
</details>

<details>
    <summary><strong>Aggregation</strong></summary>
    Aggregation is a form of association in OOP where one class contains references to other classes as part of its structure. It represents a "has-a" relationship between objects.
</details>

<details>
    <summary><strong>Abstraction</strong></summary>
    Abstraction is the process of simplifying complex systems by focusing on essential details while hiding unnecessary complexities. It allows developers to work with high-level concepts without dealing with low-level implementation details.
</details>

<details>
    <summary><strong>Encapsulation</strong></summary>
    Encapsulation is the practice of bundling data and methods that operate on that data into a single unit called a class. It helps in data hiding and maintaining data integrity.
</details>

<details>
    <summary><strong>SOLID Principles</strong></summary>
    SOLID is an acronym representing five principles of object-oriented design: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion. These principles help create modular and maintainable software.
</details>

<details>
    <summary><strong>Single Responsibility Principle (SRP)</strong></summary>
    The Single Responsibility Principle (SRP) is one of the SOLID principles in software design. It states that a class should have only one reason to change, meaning it should have a single responsibility or function within the system.
</details>

<details>
    <summary><strong>Open-Closed Principle (OCP)</strong></summary>
    The Open-Closed Principle (OCP) is another SOLID principle that encourages software entities to be open for extension but closed for modification. It promotes the use of abstract classes and interfaces to allow for new functionality without changing existing code.
</details>

<details>
    <summary><strong>Liskov Substitution Principle (LSP)</strong></summary>
    The Liskov Substitution Principle (LSP) is a SOLID principle that states that objects of a derived class should be able to replace objects of the base class without affecting the correctness of the program. It ensures that inheritance hierarchies maintain the expected behaviors.
</details>

<details>
    <summary><strong>Interface Segregation Principle (ISP)</strong></summary>
    The Interface Segregation Principle (ISP) is another SOLID principle that suggests that clients should not be forced to depend on interfaces they do not use. It encourages the creation of specific, client-focused interfaces rather than large, general-purpose ones.
</details>

<details>
    <summary><strong>Dependency Inversion Principle (DIP)</strong></summary>
    The Dependency Inversion Principle (DIP) is the last of the SOLID principles, and it promotes decoupling between high-level modules and low-level modules by introducing abstractions and inverting the direction of dependencies. It encourages the use of interfaces and abstract classes to achieve flexibility and maintainability.
</details>

<details>
    <summary><strong>Coupling</strong></summary>
    Coupling in software design refers to the degree of interdependence between modules or components within a system. Low coupling indicates that modules are loosely connected and can be modified independently. High coupling suggests strong dependencies and can lead to reduced flexibility and maintainability.
</details>

<details>
    <summary><strong>Cohesion</strong></summary>
    Cohesion in software design refers to the degree to which elements within a module or component are related to one another. High cohesion implies that the elements within a module are closely related in function and work together to achieve a specific purpose. It leads to more readable, maintainable, and understandable code.
</details>

<details>
    <summary><strong>Design Patterns</strong></summary>
    Design patterns are reusable solutions to common software design problems. They provide a structured approach to solving specific design challenges and promoting maintainability and extensibility.
</details>

<details>
    <summary><strong>Builder Pattern</strong></summary>
    The Builder design pattern is used to construct complex objects step by step. It separates the construction of an object from its representation, allowing for the creation of different variations of the same object.
</details>

<details>
    <summary><strong>Factory Pattern</strong></summary>
    The Factory design pattern provides an interface for creating objects but allows subclasses to alter the type of objects that will be created. It promotes loose coupling and flexibility in object creation.
</details>

<details>
    <summary><strong>Singleton Pattern</strong></summary>
    The Singleton design pattern ensures that a class has only one instance and provides a global point of access to it. It is commonly used for managing resources, configuration settings, or a single point of control.
</details>

<details>
    <summary><strong>Adapter Pattern</strong></summary>
    The Adapter design pattern allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code.
</details>

<details>
    <summary><strong>Decorator Pattern</strong></summary>
    The Decorator design pattern allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class. It is useful for extending the functionality of classes.
</details>

<details>
    <summary><strong>Proxy Pattern</strong></summary>
    The Proxy design pattern provides a surrogate or placeholder for another object to control access to it. It can be used for various purposes, such as lazy initialization, access control, or logging.
</details>

<details>
    <summary><strong>Observer Pattern</strong></summary>
    The Observer design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is commonly used in event handling and UI updates.
</details>

<details>
    <summary><strong>Command Pattern</strong></summary>
    The Command design pattern encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations. It is used to decouple sender and receiver objects.
</details>

<details>
    <summary><strong>Strategy Pattern</strong></summary>
    The Strategy design pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. It allows clients to choose the appropriate algorithm at runtime, promoting flexibility and maintainability.
</details>

<details>
    <summary><strong>Chain Of Responsibility Pattern</strong></summary>
    The Chain of Responsibility design pattern passes a request along a chain of handlers. Each handler decides either to process the request or to pass it to the next handler in the chain. It is used for achieving loose coupling of senders and receivers.
</details>

<details>
    <summary><strong>Idempotency</strong></summary>
    Idempotency means that an operation or function, when applied multiple times, has the same result as if it were applied once. In the context of APIs, marking an operation as idempotent ensures that even if the same request is sent multiple times, it has the same effect as if it were sent once. This prevents unintended side effects and ensures data consistency.
</details>

<details>
    <summary><strong>Concurrency</strong></summary>
    Concurrency is the ability of a system to handle multiple tasks simultaneously. It's important for designing efficient software that can make the most of modern multi-core processors.
</details>

<details>
    <summary><strong>Domain-Driven Design (DDD)</strong></summary>
    Domain-Driven Design (DDD) is an architectural and design approach that focuses on modeling a software system based on the domain it operates within. It emphasizes a shared understanding between domain experts and developers, resulting in a more effective and maintainable design.
</details>

<details>
    <summary><strong>Command Query Responsibility Segregation (CQRS)</strong></summary>
    Command Query Responsibility Segregation (CQRS) is an architectural pattern that separates the handling of commands (write operations) from queries (read operations) in a system. It allows for optimizing and scaling the two types of operations independently, improving system performance and maintainability.
</details>

<details>
    <summary><strong>Event Sourcing</strong></summary>
    Event Sourcing is a design pattern that involves capturing all changes to an application's state as a series of immutable events. It provides a comprehensive history of actions and enables features like auditing, debugging, and state reconstruction in software systems.
</details>

<details>
    <summary><strong>Eventual Consistency</strong></summary>
    Eventual Consistency is a consistency model used in distributed systems, where it is acknowledged that, given time and certain conditions, all replicas of data will eventually become consistent. It is a key consideration in designing highly available distributed systems.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Algorithms & Data Strcutures

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Algorithms</strong></summary>
    Algorithms are sets of instructions or steps to accomplish a specific task or solve problems. They are fundamental in computing, guiding how data is processed and analyzed efficiently.
</details>

<details>
    <summary><strong>Big O Notation</strong></summary>
    Big O Notation measures algorithm efficiency by how run time increases with input size. It's key for understanding and comparing different algorithms, especially in large-scale systems. Examples include O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n), and O(n!).
</details>

<details>
    <summary><strong>Data Structures</strong></summary>
    Data Structures are ways to organize and store data, like arrays, trees, and graphs. They're the backbone of efficient algorithms and enable effective data management and access.
</details>

<details>
    <summary><strong>Arrays</strong></summary>
    Arrays store elements in a fixed-size, sequential collection. They offer fast access by index but have fixed sizes and require contiguous memory allocation.
</details>

<details>
    <summary><strong>Linked Lists</strong></summary>
    Linked Lists consist of nodes linked together in a sequence. Each node contains data and a reference to the next node. They allow for dynamic size and easy insertion/deletion.
</details>

<details>
    <summary><strong>Stacks</strong></summary>
    Stacks operate on a Last In, First Out (LIFO) principle. They are used for tasks like backtracking and function call management, allowing only top-element access.
</details>

<details>
    <summary><strong>Queues</strong></summary>
    Queues follow a First In, First Out (FIFO) order. They are essential in managing tasks in a sequential process, like printer task scheduling.
</details>

<details>
    <summary><strong>Hash Tables</strong></summary>
    Hash Tables store key-value pairs for efficient data retrieval. They use a hash function to compute an index for each key, enabling fast lookups.
</details>

<details>
    <summary><strong>Trees</strong></summary>
    Trees are hierarchical structures, with a root value and subtrees of children with a parent node. They are vital in representing hierarchical data, like file systems.
</details>

<details>
    <summary><strong>Heaps</strong></summary>
    Heaps are specialized trees ensuring the highest (or lowest) priority element remains at the top, commonly used in priority queues.
</details>

<details>
    <summary><strong>Graphs</strong></summary>
    Graphs consist of nodes (or vertices) connected by edges. They represent networks, such as social connections or routing systems.
</details>

<details>
    <summary><strong>Trie</strong></summary>
    Trie, or prefix tree, stores strings in a tree-like structure, allowing for efficient retrieval of words or prefixes in a dataset.
</details>

<details>
    <summary><strong>Sets</strong></summary>
    Sets are collections of unique elements. They are used for storing non-duplicate values and for operations like union and intersection.
</details>

<details>
    <summary><strong>Recursion</strong></summary>
    Recursion is a technique where a function calls itself to solve smaller parts of a problem. It simplifies complex problems, often used in sorting, searching, and traversing structures.
</details>

<details>
    <summary><strong>Dynamic Programming</strong></summary>
    Dynamic Programming is a strategy to solve complex problems by breaking them down into simpler subproblems. It stores the results of subproblems to avoid repeated work, enhancing efficiency.
</details>

<details>
    <summary><strong>Memoization</strong></summary>
    Memoization is an optimization technique that stores the results of expensive function calls and returns the cached result for repeated calls. It's effective in reducing computing time.
</details>

<details>
    <summary><strong>Graph Theory</strong></summary>
    Graph Theory deals with graphs, consisting of nodes and connections. It's fundamental in network analysis, path finding in maps, and solving various interconnected problems.
</details>

<details>
    <summary><strong>Sorting</strong></summary>
    Sorting is arranging data in a certain order. Essential for data analysis and optimization, various algorithms provide different ways to sort efficiently based on the context.
</details>

<details>
    <summary><strong>Searching</strong></summary>
    Searching is finding specific data in a structure. Vital in database management and information retrieval, effective search algorithms are key to fast and accurate data access.
</details>

---

![Divider](.github/assets/divider-1.jpg)

### âž¤ Infra

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Infrastructure

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Virtualization</strong></summary>
    Virtualization involves creating virtual versions of physical resources like servers and networks. This technology enables multiple virtual systems and applications to run on a single physical machine, maximizing resource utilization and reducing costs.
</details>

<details>
    <summary><strong>Cloud Computing</strong></summary>
    Cloud Computing delivers computing servicesâ€”servers, storage, databases, networking, software, analytics, and moreâ€”over the Internet ("the cloud"). It provides flexibility, scalability, and cost efficiency, allowing users to pay only for cloud services they use.
</details>

<details>
    <summary><strong>Load Balancing</strong></summary>
    Load Balancing is the process of distributing network or application traffic across multiple servers. It improves application responsiveness and availability by ensuring no single server bears too much demand, thus preventing overloading and potential downtime.
</details>

<details>
    <summary><strong>Disaster Recovery</strong></summary>
    Disaster Recovery is a comprehensive strategy for ensuring business continuity in case of catastrophic events. It includes planning, backup solutions, and procedures to recover IT systems and data after disasters like natural disasters, hardware failures, or cyberattacks.
</details>

<details>
    <summary><strong>Containerization</strong></summary>
    Containerization is the use of containers to deploy applications in lightweight, portable environments. Containers package an application's code, libraries, and dependencies together, providing consistent environments and isolating the application from the underlying system.
</details>

<details>
    <summary><strong>Infrastructure as Code (IaC)</strong></summary>
    Infrastructure as Code (IaC) is the management of infrastructure (networks, virtual machines, load balancers, etc.) in a descriptive model, using code. This allows for automatic management and provisioning, improving infrastructure deployment speed and reliability.
</details>

<details>
    <summary><strong>Monitoring</strong></summary>
    Monitoring in IT involves continuously tracking system performance, health, and activities. This is crucial for preemptively detecting and addressing issues, ensuring systems operate efficiently and securely.
</details>

<details>
    <summary><strong>Logging</strong></summary>
    Logging is the process of recording events and data changes in software applications and IT systems. It's essential for troubleshooting, security audits, and understanding system behavior over time.
</details>

<details>
    <summary><strong>Data Centers</strong></summary>
    Data Centers are specialized facilities that house computer systems, networking equipment, and storage to support the centralized processing and management of data.
</details>

<details>
    <summary><strong>Cloud</strong></summary>
    Cloud computing provides on-demand access to a shared pool of computing resources, such as servers, storage, and services, over the internet.
</details>

<details>
    <summary><strong>Server Clustering</strong></summary>
    Server Clustering involves grouping multiple servers together to work as a single unit, enhancing availability and fault tolerance.
</details>

<details>
    <summary><strong>Network Segmentation</strong></summary>
    Network Segmentation is the practice of dividing a network into smaller, isolated segments to enhance security and control access.
</details>

<details>
    <summary><strong>Network Topology</strong></summary>
    Network Topology defines the physical or logical layout of a network, including how devices and components are connected.
</details>

<details>
    <summary><strong>Router</strong></summary>
    A Router is a network device that forwards data packets between different networks, determining the best path for data transmission.
</details>

<details>
    <summary><strong>Switch</strong></summary>
    A Switch is a network device that connects devices within the same network and uses MAC addresses to forward data to the appropriate recipient.
</details>

<details>
    <summary><strong>IP (Internet Protocol)</strong></summary>
    IP (Internet Protocol) is the set of rules that governs how data packets are sent, routed, and received across networks, including the internet.
</details>

<details>
    <summary><strong>Bandwidth</strong></summary>
    Bandwidth refers to the maximum data transfer rate of a network or internet connection, often measured in bits per second (bps).
</details>

<details>
    <summary><strong>LAN (Local Area Network)</strong></summary>
    A LAN is a network that covers a limited geographic area, typically within a single building or campus, and allows devices to connect and communicate locally.
</details>

<details>
    <summary><strong>VLANs (Virtual LANs)</strong></summary>
    VLANs are virtual LANs that enable network segmentation and isolation within a physical network, improving security and traffic management.
</details>

<details>
    <summary><strong>Network Protocols</strong></summary>
    Network Protocols are rules and conventions that govern communication between devices and systems on a network, ensuring data exchange consistency.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## DevOps & SRE

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Continuous Integration (CI)</strong></summary>
    Continuous Integration is a development practice where code changes are automatically integrated and tested frequently. It aims to identify and resolve integration issues early in the development process.
</details>

<details>
    <summary><strong>Continuous Delivery (CD)</strong></summary>
    Continuous Delivery extends CI by automating the release process, ensuring that code changes can be quickly and reliably delivered to production or staging environments.
</details>

<details>
    <summary><strong>Infrastructure as Code (IaC)</strong></summary>
    Infrastructure as Code involves managing and provisioning infrastructure using code and automation. It enables consistent and repeatable infrastructure deployments.
</details>

<details>
    <summary><strong>Deployment</strong></summary>
    Deployment is the process of releasing software or application updates into production or staging environments. It involves configuring, installing, and making the software available for use.
</details>

<details>
    <summary><strong>Rollback</strong></summary>
    Rollback is a mechanism to revert to a previous version of an application or system in case of issues or failures during deployment. It ensures system stability and minimizes downtime.
</details>

<details>
    <summary><strong>Orchestration</strong></summary>
    Orchestration involves coordinating and automating multiple tasks or processes to achieve a specific outcome. It's crucial for managing complex workflows in software development and operations.
</details>

<details>
    <summary><strong>Service Level Objectives (SLOs)</strong></summary>
    Service Level Objectives are specific, measurable goals that define the reliability and performance targets for a service. They help teams maintain the desired level of service quality.
</details>

<details>
    <summary><strong>Service Level Agreement (SLA)</strong></summary>
    SLA is a formal contract that outlines the agreed-upon level of service between a service provider and its customers. It defines expectations and consequences for not meeting the specified criteria.
</details>

<details>
    <summary><strong>Service Level Indicators (SLIs)</strong></summary>
    Service Level Indicators are metrics used to measure the performance and behavior of a service. They provide quantifiable data to assess the service's reliability and adherence to SLOs.
</details>

<details>
    <summary><strong>Reliability</strong></summary>
    Reliability is the ability of a system or service to consistently perform its intended function without failures. It's a core focus of SRE practices.
</details>

<details>
    <summary><strong>Incident Management</strong></summary>
    Incident Management involves the processes and practices for detecting, responding to, and resolving service disruptions or incidents. It aims to minimize downtime and customer impact.
</details>

<details>
    <summary><strong>Alerting</strong></summary>
    Alerting involves setting up notifications to inform teams about potential issues or anomalies in the system. Effective alerting is crucial for proactive incident response.
</details>

<details>
    <summary><strong>Toil Reduction</strong></summary>
    Toil Reduction is the practice of automating repetitive, manual operational tasks to reduce the burden on SRE teams. It frees up time for more strategic work.
</details>

<details>
    <summary><strong>Post-Mortems</strong></summary>
    Post-Mortems are detailed analyses conducted after incidents to understand their causes, effects, and prevention strategies. They emphasize a blameless culture and learning from failures.
</details>

<details>
    <summary><strong>Change Management</strong></summary>
    Change Management is the process of planning, testing, and implementing changes to a system or service in a controlled manner. It ensures that changes don't negatively impact reliability.
</details>

<details>
    <summary><strong>Capacity Planning</strong></summary>
    Capacity Planning is the process of forecasting and provisioning resources to meet current and future service demands. It ensures that systems can handle expected workloads.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Network Security

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Firewall</strong></summary>
    A Firewall is a network security device that monitors and controls incoming and outgoing network traffic. It acts as a barrier between a trusted internal network and untrusted external networks, filtering traffic based on predefined rules.
</details>

<details>
    <summary><strong>Intrusion Detection System (IDS)</strong></summary>
    An Intrusion Detection System is a security tool that monitors network or system activities for malicious behavior or policy violations. It alerts administrators to potential threats but does not actively block them.
</details>

<details>
    <summary><strong>Intrusion Prevention System (IPS)</strong></summary>
    An Intrusion Prevention System goes beyond IDS by not only detecting but also actively blocking or mitigating security threats. It can take automated actions to protect the network.
</details>

<details>
    <summary><strong>VPN (Virtual Private Network)</strong></summary>
    A Virtual Private Network is a secure connection that allows remote users or offices to access a private network over the internet securely. It encrypts data and ensures privacy and confidentiality.
</details>

<details>
    <summary><strong>Network Segmentation</strong></summary>
    Network Segmentation is the practice of dividing a network into smaller, isolated segments or zones to enhance security. It limits the lateral movement of threats within the network.
</details>

<details>
    <summary><strong>Access Control Lists (ACLs)</strong></summary>
    Access Control Lists are rules or lists of permissions that control access to network resources. They specify which users or systems are allowed or denied access to specific resources.
</details>

<details>
    <summary><strong>Security Appliances</strong></summary>
    Security Appliances are specialized hardware or software devices designed to protect network infrastructure. They include firewalls, intrusion detection systems, and anti-malware appliances.
</details>

<details>
    <summary><strong>Network Hardening</strong></summary>
    Network Hardening is the process of securing a network by implementing security measures and best practices to reduce vulnerabilities and protect against cyberattacks.
</details>

<details>
    <summary><strong>DDoS Mitigation (Distributed Denial of Service)</strong></summary>
    DDoS Mitigation involves strategies and technologies to protect a network or system from large-scale, malicious traffic floods that can overwhelm and disrupt services.
</details>

<details>
    <summary><strong>Network Access Control (NAC)</strong></summary>
    Network Access Control is a security solution that manages and enforces policies for devices trying to connect to a network. It ensures only authorized and compliant devices gain access.
</details>

<details>
    <summary><strong>Security Patch Management</strong></summary>
    Security Patch Management is the process of identifying, applying, and monitoring software updates and patches to address security vulnerabilities and keep systems secure.
</details>

<details>
    <summary><strong>Social Engineering</strong></summary>
    Social Engineering is a form of cyberattack that manipulates individuals into revealing confidential information or performing actions that compromise security.
</details>

<details>
    <summary><strong>Spam Filtering</strong></summary>
    Spam Filtering is the practice of detecting and blocking unwanted or unsolicited email messages, known as spam, to prevent them from reaching users' inboxes.
</details>

<details>
    <summary><strong>Penetration Testing</strong></summary>
    Penetration Testing, also known as ethical hacking, involves simulating cyberattacks on a system to identify vulnerabilities and weaknesses that could be exploited by malicious actors.
</details>

<details>
    <summary><strong>Vulnerability Assessment</strong></summary>
    Vulnerability Assessment is the process of systematically identifying, evaluating, and prioritizing security vulnerabilities in a system or network to reduce potential risks.
</details>

---

![Divider](.github/assets/divider-1.jpg)

### âž¤ Back

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## System Architecture

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Scalability</strong></summary>
    Scalability refers to a system's ability to handle an increasing workload by adding resources or components. It ensures that the system can grow to accommodate higher demands without a significant drop in performance.
</details>

<details>
    <summary><strong>Availability</strong></summary>
    Availability is the measure of how accessible and operational a system is over a specified period. High availability systems are designed to minimize downtime and ensure that services are consistently accessible.
</details>

<details>
    <summary><strong>Redundancy</strong></summary>
    Redundancy in system architecture refers to the duplication of critical components or systems to ensure continued operation in case of component failures. It enhances system reliability and availability.
</details>

<details>
    <summary><strong>Resiliency</strong></summary>
    Resiliency refers to the ability of a system to maintain its functionality and availability in the face of failures or disruptions. It involves designing systems to recover gracefully from faults, ensuring continuous operation.
</details>

<details>
    <summary><strong>Elasticity</strong></summary>
    Elasticity is the capability of a system to automatically scale resources up or down in response to changes in workload or demand. It allows for efficient resource utilization and cost management.
</details>

<details>
    <summary><strong>Fault Tolerance</strong></summary>
    Fault tolerance is the ability of a system to continue operating without interruption in the presence of hardware or software faults. It involves mechanisms to detect, isolate, and recover from failures.
</details>

<details>
    <summary><strong>Monolithic Architecture</strong></summary>
    Monolithic Architecture is a traditional approach where all components of an application are tightly integrated into a single, self-contained system. It typically consists of a single codebase, database, and runtime environment.
</details>

<details>
    <summary><strong>Serverless Architecture</strong></summary>
    Serverless architecture allows developers to focus on writing code without managing server infrastructure. It relies on cloud providers to automatically scale, manage, and allocate resources as needed.
</details>

<details>
    <summary><strong>Service-Oriented Architecture (SOA)</strong></summary>
    Service-Oriented Architecture organizes software components as services that can be accessed remotely, promoting modularity and interoperability. Services communicate through standardized interfaces.
</details>

<details>
    <summary><strong>Microservices Architecture</strong></summary>
    Microservices architecture is an approach to software development where an application is composed of small, independent services that communicate through APIs. It promotes flexibility and scalability in complex systems.
</details>

<details>
    <summary><strong>Event-Driven Architecture</strong></summary>
    Event-Driven Architecture focuses on communication between components or microservices via events and messages. It allows for loosely coupled, scalable systems that can respond to events in real-time.
</details>

<details>
    <summary><strong>Layered Architecture</strong></summary>
    Layered Architecture separates software into distinct layers (e.g., presentation, business logic, data) for modularity and maintainability. Each layer has a specific responsibility, and communication often occurs vertically between adjacent layers.
</details>

<details>
    <summary><strong>Hexagonal Architecture (Ports and Adapters)</strong></summary>
    Hexagonal (Ports and Adapters) Architecture isolates application core logic from external dependencies using ports and adapters for flexibility. It encourages a clear separation between the core domain and external systems.
</details>

<details>
    <summary><strong>Reactive Architecture</strong></summary>
    Reactive Architecture designs systems to be responsive, resilient, and elastic, often using reactive programming principles. It handles events and asynchronous data flows efficiently, making it suitable for real-time applications.
</details>

<details>
    <summary><strong>Multi-tenancy</strong></summary>
    Multi-tenant architecture refers to a system's ability to serve multiple clients, users, or tenants while maintaining isolation and customization for each. It allows shared resources and infrastructure to accommodate various users or organizations within the same software instance.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Databases

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Relational Database</strong></summary>
    A Relational Database stores data in structured tables with defined relationships between them. It uses SQL for querying and managing data.
</details>

<details>
    <summary><strong>NoSQL Database</strong></summary>
    A NoSQL Database is a non-relational database that stores data in various formats, such as document, key-value, or columnar, and is suitable for unstructured or semi-structured data.
</details>

<details>
    <summary><strong>Data Modeling</strong></summary>
    Data Modeling is the process of designing the structure and organization of data within a database, including defining tables, relationships, and attributes.
</details>

<details>
    <summary><strong>SQL (Structured Query Language)</strong></summary>
    SQL is a domain-specific language used for managing and querying relational databases. It enables users to retrieve, manipulate, and update data.
</details>

<details>
    <summary><strong>Indexing</strong></summary>
    Indexing involves creating data structures to optimize data retrieval in a database. It speeds up query performance by allowing quick access to specific data.
</details>

<details>
    <summary><strong>ACID Properties</strong></summary>
    ACID (Atomicity, Consistency, Isolation, Durability) Properties are a set of characteristics that ensure database transactions are reliable and maintain data integrity.
</details>

<details>
    <summary><strong>Transactions</strong></summary>
    Transactions are sequences of database operations that are treated as a single, indivisible unit. They guarantee data consistency and can be committed or rolled back.
</details>

<details>
    <summary><strong>Normalization</strong></summary>
    Normalization is the process of organizing data in a database to reduce data redundancy and improve data integrity by eliminating data anomalies.
</details>

<details>
    <summary><strong>Denormalization</strong></summary>
    Denormalization is the reverse of normalization and involves adding redundant data to a database to improve query performance by reducing joins.
</details>

<details>
    <summary><strong>Backup and Recovery</strong></summary>
    Backup and Recovery involve creating copies of data to prevent data loss and restoring data to its previous state in case of failures or disasters.
</details>

<details>
    <summary><strong>BLOB (Binary Large Object)</strong></summary>
    BLOB is a data type that can store large binary data, such as images, videos, or documents, in a database.
</details>

<details>
    <summary><strong>OLTP (Online Transaction Processing)</strong></summary>
    OLTP is a database processing method focused on handling real-time transactional workloads, such as data insertions, updates, and deletions.
</details>

<details>
    <summary><strong>OLAP (Online Analytical Processing)</strong></summary>
    OLAP is a database processing method designed for complex querying and analysis of historical data to support decision-making and reporting.
</details>

<details>
    <summary><strong>BASE (Basically Available, Soft state, Eventually consistent)</strong></summary>
    BASE is an alternative approach to database consistency that prioritizes availability and responsiveness over strict consistency, aiming for eventual consistency.
</details>

<details>
    <summary><strong>Stored Procedures</strong></summary>
    Stored Procedures are precompiled and stored database procedures that can be executed on demand. They improve performance and maintain consistency in database operations.
</details>

<details>
    <summary><strong>Partitioning</strong></summary>
    Partitioning is the technique of dividing large tables into smaller, manageable segments to enhance query performance and data management.
</details>

<details>
    <summary><strong>Replication</strong></summary>
    Replication involves copying and synchronizing data from one database to one or more replicas. It provides fault tolerance and load distribution.
</details>

<details>
    <summary><strong>Sharding</strong></summary>
    Sharding is a database scaling technique where data is distributed across multiple databases or servers to improve performance and handle large workloads.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Backend

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Synchronization</strong></summary>
    Synchronization is the coordination of multiple threads or processes to ensure orderly and consistent execution. It is essential for preventing race conditions and maintaining data integrity in concurrent systems.
</details>

<details>
    <summary><strong>Parallelism</strong></summary>
    Parallelism is the concurrent execution of tasks or processes to improve performance and efficiency. It can be achieved through multi-threading or multi-processing and is commonly used in backend systems for tasks like data processing.
</details>

<details>
    <summary><strong>Deadlock</strong></summary>
    Deadlock is a situation in concurrent programming where two or more threads or processes are unable to proceed because each is waiting for the other to release a resource or take an action.
</details>

<details>
    <summary><strong>Race Condition</strong></summary>
    A race condition occurs when two or more threads or processes access shared data concurrently, potentially leading to unpredictable and undesirable behavior if not properly synchronized.
</details>

<details>
    <summary><strong>Thread Safety</strong></summary>
    Thread safety is a property of software that ensures it behaves correctly and predictably when multiple threads are executing simultaneously. It involves using synchronization techniques to prevent data corruption and inconsistencies.
</details>

<details>
    <summary><strong>Locking Mechanisms</strong></summary>
    Locking mechanisms are used in concurrent programming to control access to shared resources. They include mutexes, semaphores, and other synchronization primitives that prevent multiple threads from accessing the same resource simultaneously.
</details>

<details>
    <summary><strong>Critical Section</strong></summary>
    A critical section is a portion of code in which access to shared resources is controlled and synchronized to avoid race conditions and maintain data consistency in multi-threaded or multi-process environments.
</details>

<details>
    <summary><strong>Profiling</strong></summary>
    Profiling involves analyzing the performance of a software application to identify bottlenecks and optimize resource usage. It helps in fine-tuning the application for better efficiency.
</details>

<details>
    <summary><strong>Debugging</strong></summary>
    Debugging is the process of identifying and resolving issues or errors in software code to ensure the proper functioning of the system. It involves locating and fixing bugs, exceptions, or unexpected behavior.
</details>

<details>
    <summary><strong>Rate Limiting</strong></summary>
    Rate limiting is a technique used to control the number of requests or connections that a client can make to a server within a specified time frame. It helps prevent overloading the server and ensures fair usage of resources.
</details>

<details>
    <summary><strong>Connection Pooling</strong></summary>
    Connection pooling is a mechanism that maintains a pool of reusable database connections in a database server. It helps improve performance and efficiency by reducing the overhead of establishing and closing database connections for each request.
</details>

<details>
    <summary><strong>RESTful APIs</strong></summary>
    RESTful APIs, which stands for Representational State Transfer, are a design pattern for creating web services that are easy to understand and use. They follow a set of principles that leverage HTTP methods and status codes to enable scalable and stateless communication between clients and servers.
</details>

<details>
    <summary><strong>Parsing</strong></summary>
    Parsing is the act of analyzing and interpreting data or text to extract relevant information or convert it into a structured format. A parser is a software component responsible for parsing, converting, or transforming data from one representation to another.
</details>

<details>
    <summary><strong>Populating</strong></summary>
    Populating involves filling a template or data structure with relevant information. This can apply to various contexts, such as populating a database with initial data, filling a web page template with dynamic content, or populating data structures for processing.
</details>

<details>
    <summary><strong>Hydration</strong></summary>
    Hydration involves converting data from strings or raw formats into the appropriate objects or data structures for use within an application. This process is typically performed after retrieving data from a database, ensuring that it is in the correct format for application logic.
</details>

<details>
    <summary><strong>Propagation</strong></summary>
    Propagation refers to the act of sending, delivering, or queuing commands or events for execution. It is a fundamental concept in event-driven and distributed systems, where actions or tasks need to be communicated and carried out across different components or services.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Information Security

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Data Encryption</strong></summary>
    Data Encryption is the process of converting data into a code to prevent unauthorized access. It ensures that only authorized parties can decipher and access the information.
</details>

<details>
    <summary><strong>Access Control</strong></summary>
    Access Control is the practice of regulating who can access specific resources or data in a system or network. It includes authentication and authorization mechanisms.
</details>

<details>
    <summary><strong>Malware Protection</strong></summary>
    Malware Protection involves the use of software and security measures to detect, prevent, and remove malicious software (malware) such as viruses, spyware, and ransomware.
</details>

<details>
    <summary><strong>Phishing</strong></summary>
    Phishing is a cyberattack method where attackers trick individuals into revealing sensitive information, often through deceptive emails or websites that mimic legitimate sources.
</details>

<details>
    <summary><strong>Data Loss Prevention (DLP)</strong></summary>
    Data Loss Prevention is a set of strategies and technologies to prevent unauthorized access, sharing, or leakage of sensitive data to protect against data breaches.
</details>

<details>
    <summary><strong>Security Incident Response</strong></summary>
    Security Incident Response is a structured approach to handling and managing security incidents, including detection, containment, eradication, and recovery.
</details>

<details>
    <summary><strong>Threat Intelligence</strong></summary>
    Threat Intelligence is information about current and potential cybersecurity threats and vulnerabilities. It helps organizations make informed decisions and enhance security measures.
</details>

<details>
    <summary><strong>Identity and Access Management (IAM)</strong></summary>
    Identity and Access Management is a framework and set of technologies to manage and secure user identities and their access to resources in a system or network.
</details>

<details>
    <summary><strong>Security Assessment</strong></summary>
    Security Assessment involves evaluating and analyzing an organization's security posture to identify vulnerabilities, risks, and areas that require improvement.
</details>

<details>
    <summary><strong>Risk Assessment</strong></summary>
    Risk Assessment is the process of identifying, assessing, and prioritizing potential security risks and threats to an organization's assets and operations.
</details>

<details>
    <summary><strong>Security Policies and Procedures</strong></summary>
    Security Policies and Procedures are documented guidelines and rules that define the organization's approach to security, including standards and best practices.
</details>

<details>
    <summary><strong>Security Compliance</strong></summary>
    Security Compliance refers to adhering to industry-specific regulations, standards, and best practices to ensure that security controls meet required criteria.
</details>

<details>
    <summary><strong>Security Auditing</strong></summary>
    Security Auditing involves examining and assessing security controls, processes, and policies to verify compliance, detect issues, and improve security.
</details>

<details>
    <summary><strong>Password Management</strong></summary>
    Password Management encompasses policies and practices for creating, securing, and managing user passwords to enhance authentication security.
</details>

<details>
    <summary><strong>Insider Threat Detection</strong></summary>
    Insider Threat Detection focuses on monitoring and identifying potential security threats and risks posed by individuals within an organization, including employees and contractors.
</details>

<details>
    <summary><strong>Hashing</strong></summary>
    Hashing transforms data into a unique, fixed-size hash code. It enables quick data retrieval, crucial in databases and cybersecurity for efficient storage and secure data handling.
</details>

---

![Divider](.github/assets/divider-1.jpg)

### âž¤ Front

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## UI / UX

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Wireframing</strong></summary>
    Wireframing is the process of creating visual representations of web page layouts and structures. These wireframes serve as a blueprint for designers and developers, outlining the placement of elements, content, and functionality, without delving into design details.
</details>

<details>
    <summary><strong>Color Theory</strong></summary>
    Color Theory is the study of how colors interact and impact human perception. In design, it plays a crucial role in choosing color palettes that convey messages, establish brand identity, and create visual harmony in user interfaces.
</details>

<details>
    <summary><strong>Heuristic Evaluation</strong></summary>
    Heuristic Evaluation is a usability evaluation method where experts assess a user interface against a set of predefined usability principles or "heuristics." It helps identify usability issues and areas for improvement in a systematic manner.
</details>

<details>
    <summary><strong>Contextual Inquiry</strong></summary>
    Contextual Inquiry is a user research method that involves observing users in their real-world environments while they interact with a product. It provides valuable insights into user behaviors, needs, and challenges, helping designers create context-aware solutions.
</details>

<details>
    <summary><strong>Localization</strong></summary>
    Localization is the adaptation of a mobile app to different languages, cultures, and regions. It ensures that the app is accessible and relevant to a global audience, enhancing user engagement and reach.
</details>

<details>
    <summary><strong>User Personas</strong></summary>
    User Personas are detailed profiles that represent different user types or personas. They help designers empathize with users' goals, behaviors, and pain points, enabling the creation of more user-centric designs and experiences.
</details>

<details>
    <summary><strong>Information Architecture</strong></summary>
    Information Architecture focuses on organizing and structuring content within a product to improve findability and navigation. It defines how information is categorized, labeled, and presented to users for an intuitive and efficient user experience.
</details>

<details>
    <summary><strong>Style Guides</strong></summary>
    Style Guides establish visual and design standards for a product, ensuring a consistent and cohesive look and feel. They include guidelines for typography, color schemes, layout, and other design elements to maintain brand identity and user recognition.
</details>

<details>
    <summary><strong>Emotional Design</strong></summary>
    Emotional Design is an approach that aims to create products that evoke specific emotions or feelings in users. It involves the use of visual elements, storytelling, and interactive features to connect with users on an emotional level and enhance their overall experience.
</details>

<details>
    <summary><strong>User-Centered Design</strong></summary>
    User-Centered Design is a design approach that prioritizes creating products and experiences tailored to the specific needs and preferences of users. It involves conducting user research, gathering feedback, and iterating on designs to ensure usability and user satisfaction.
</details>

<details>
    <summary><strong>Interaction Design</strong></summary>
    Interaction Design focuses on crafting seamless and intuitive user experiences by designing the way users interact with a product or interface. It involves defining user flows, transitions, and behaviors to ensure ease of use and user satisfaction.
</details>

<details>
    <summary><strong>Mobile-first Design</strong></summary>
    Mobile-first Design is a design strategy that prioritizes designing for mobile devices before considering larger screens. It ensures that user experiences are optimized for smaller screens and progressively enhanced for larger ones, reflecting the shift toward mobile usage.
</details>

<details>
    <summary><strong>Design Thinking</strong></summary>
    Design Thinking is a problem-solving approach that emphasizes empathy, ideation, and iteration. It encourages multidisciplinary teams to collaborate, empathize with users, brainstorm creative solutions, and iterate through prototyping to address complex problems effectively.
</details>

<details>
    <summary><strong>Microinteractions</strong></summary>
    Microinteractions are subtle, momentary animations or feedback in a user interface. They enhance user engagement and provide immediate visual or audio cues in response to user actions, contributing to a more interactive and enjoyable user experience.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Web Frontend

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Responsive Design</strong></summary>
    Responsive Design ensures web pages work well on various devices by dynamically adjusting layout. It's crucial for user engagement and SEO, involving flexible grids and media queries.
</details>

<details>
    <summary><strong>Cross-Browser Compatibility</strong></summary>
    This concept ensures that a website functions consistently across different browsers. It's key for reaching a broad audience and involves testing and tweaking for browser-specific quirks.
</details>

<details>
    <summary><strong>Accessibility (a11y)</strong></summary>
    Accessibility is about making web content usable for everyone, including those with disabilities. It involves following standards like WCAG and implementing features like keyboard navigation.
</details>

<details>
    <summary><strong>HTML</strong></summary>
    HTML is the foundation of web content, structuring elements like text, images, and links. Understanding semantic HTML is crucial for SEO, accessibility, and maintaining clean code.
</details>

<details>
    <summary><strong>CSS</strong></summary>
    CSS styles web pages and controls layout. Mastery involves understanding box model, flexbox, grid systems, and responsive design techniques for visually appealing, functional UIs.
</details>

<details>
    <summary><strong>JavaScript</strong></summary>
    JavaScript adds interactivity to web pages. It ranges from basic DOM manipulations to complex applications, crucial for dynamic content and modern web application development.
</details>

<details>
    <summary><strong>State Management</strong></summary>
    State Management is key in handling data and UI state in dynamic applications. It involves patterns and tools like Redux or Context API to maintain consistency and manage data flow.
</details>

<details>
    <summary><strong>Progressive Web Apps (PWAs)</strong></summary>
    PWAs combine the best of web and mobile apps. They're important for creating fast, engaging web applications that work offline and mimic native app behavior.
</details>

<details>
    <summary><strong>Web Components</strong></summary>
    Web Components allow for creating reusable custom elements with encapsulated functionality. They are integral in writing clean, maintainable code for complex web applications.
</details>

<details>
    <summary><strong>DOM (Document Object Model)</strong></summary>
    The DOM is an API for HTML and XML documents, providing a structured representation of the document. Understanding the DOM is essential for dynamic content manipulation and event handling.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Mobile Development

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Native App</strong></summary>
    A Native App is designed and developed for a specific mobile operating system (e.g., iOS or Android). It offers optimal performance and access to device-specific features but requires separate development for each platform.
</details>

<details>
    <summary><strong>Cross-Platform App</strong></summary>
    A Cross-Platform App is built using a single codebase and can run on multiple mobile operating systems (e.g., iOS and Android). It offers cost-efficiency and faster development but may have some performance trade-offs.
</details>

<details>
    <summary><strong>Push Notifications</strong></summary>
    Push Notifications are messages sent from a mobile app to a user's device. They provide real-time updates, reminders, or information, enhancing user engagement and retention.
</details>

<details>
    <summary><strong>App Store Optimization (ASO)</strong></summary>
    App Store Optimization is the process of optimizing a mobile app's listing on app stores (e.g., Apple App Store, Google Play) to improve its visibility and discoverability. It involves optimizing keywords, images, and descriptions to attract more downloads.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Desktop Development

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Serialization</strong></summary>
    Serialization is the process of converting data structures or objects into a format that can be easily stored, transmitted, or reconstructed. It is commonly used for data persistence and communication between different parts of a software application.
</details>

<details>
    <summary><strong>GUI (Graphical User Interface)</strong></summary>
    GUI refers to the graphical interface of a software application that allows users to interact with it using visual elements such as windows, buttons, icons, and menus. It enhances user experience by providing a visually intuitive way to interact with the software.
</details>

<details>
    <summary><strong>Electron</strong></summary>
    Electron is an open-source framework that enables the development of cross-platform desktop applications using web technologies like HTML, CSS, and JavaScript. It allows developers to create desktop apps for multiple operating systems using a single codebase.
</details>

<details>
    <summary><strong>Distribution</strong></summary>
    Distribution in software refers to the process of packaging and delivering a software application to end-users. It involves tasks like creating installers, uploading to app stores, or making it available for download, ensuring accessibility to the target audience.
</details>

<details>
    <summary><strong>Filesystem</strong></summary>
    The Filesystem is the hierarchical structure used by an operating system to organize and manage files and directories on storage devices. It provides a means to store, retrieve, and organize data within a software application.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Games Development

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Game Engine</strong></summary>
    A Game Engine is a software framework or platform that provides developers with tools and components to create, develop, and deploy video games. It offers features for rendering graphics, handling physics, managing assets, and enabling game logic, simplifying the game development process and enhancing productivity.
</details>

<details>
    <summary><strong>Rendering</strong></summary>
    Rendering refers to the process of generating output, often in the form of user interfaces or content, from source data or templates. It involves transforming data into a visually or contextually meaningful format for presentation to users or other software components.
</details>

<details>
    <summary><strong>Physics</strong></summary>
    Physics in game development simulates real-world physical behavior, including gravity, collisions, and object movement. It enhances realism and interactivity in games.
</details>

<details>
    <summary><strong>Shaders</strong></summary>
    Shaders are small programs used in game graphics to manipulate the appearance of objects and create visual effects. They control how light interacts with materials, enhancing realism and aesthetics.
</details>

<details>
    <summary><strong>Sprites</strong></summary>
    Sprites are 2D images or animations used in games to represent characters, objects, and effects. They are essential for creating game visuals and animations.
</details>

<details>
    <summary><strong>Particles</strong></summary>
    Particles are small, visual elements in games used to simulate effects like smoke, fire, rain, or explosions. They add realism and visual appeal to game environments.
</details>

<details>
    <summary><strong>Collision Detection</strong></summary>
    Collision Detection is a game mechanic that determines when game objects or characters intersect. It is crucial for handling interactions, such as character-environment collisions or object-object collisions.
</details>

<details>
    <summary><strong>Pathfinding</strong></summary>
    Pathfinding is the process of finding the best route or path for characters or objects in a game world. It is essential for creating intelligent movement and navigation within games.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## VR / AR

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Immersion</strong></summary>
    Immersion refers to the feeling of being fully absorbed in a virtual or augmented reality environment, creating a sense of presence and engagement.
</details>

<details>
    <summary><strong>Tracking</strong></summary>
    Tracking involves monitoring the position and movement of physical objects or users within the virtual or augmented reality space. It enables interactive and responsive experiences.
</details>

<details>
    <summary><strong>Stereoscopy</strong></summary>
    Stereoscopy is a technique that provides depth perception by presenting slightly different images to each eye, mimicking the way humans perceive depth in the real world.
</details>

<details>
    <summary><strong>Haptics</strong></summary>
    Haptics uses tactile feedback, such as vibrations or force feedback, to simulate the sense of touch, enhancing realism and immersion in digital environments.
</details>

<details>
    <summary><strong>3D Modeling</strong></summary>
    3D Modeling is the process of creating three-dimensional digital representations of objects or environments, essential for building realistic digital worlds.
</details>

<details>
    <summary><strong>Scene Graph</strong></summary>
    A Scene Graph is a data structure used to organize and manage the objects and entities within a digital scene, enabling efficient rendering and interactions.
</details>

<details>
    <summary><strong>Field of View</strong></summary>
    Field of View (FoV) determines the extent of the observable world in a digital environment, impacting what a user can see at a given time.
</details>

<details>
    <summary><strong>Gesture Recognition</strong></summary>
    Gesture Recognition identifies and interprets hand or body movements made by users, enabling interactive and intuitive control of digital elements.
</details>

<details>
    <summary><strong>Eye Tracking</strong></summary>
    Eye Tracking monitors the movement and focus of a user's eyes, allowing for dynamic interactions and improving rendering quality based on gaze.
</details>

<details>
    <summary><strong>Spatial Audio</strong></summary>
    Spatial Audio creates realistic soundscapes by simulating the direction and location of audio sources, enhancing immersion and situational awareness.
</details>

<details>
    <summary><strong>Simulated Environments</strong></summary>
    Simulated Environments are digitally created spaces that replicate real-world or fictional settings for various applications, including training, gaming, and simulations.
</details>

<details>
    <summary><strong>Calibration</strong></summary>
    Calibration is the process of fine-tuning and aligning sensors and devices in digital systems to ensure accurate tracking, visuals, and interactions.
</details>

<details>
    <summary><strong>Room Scaling</strong></summary>
    Room Scaling allows users to move and interact within physical spaces that match the digital environment's dimensions, offering a more immersive experience.
</details>

---

![Divider](.github/assets/divider-1.jpg)

### âž¤ Data

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Data Science

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Concept</strong></summary>
    Lorem Ipsum is simply dummy text of the printing and typesetting industry.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## AI

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Concept</strong></summary>
    Lorem Ipsum is simply dummy text of the printing and typesetting industry.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Machine Learning

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Concept</strong></summary>
    Lorem Ipsum is simply dummy text of the printing and typesetting industry.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Deep Learning

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Concept</strong></summary>
    Lorem Ipsum is simply dummy text of the printing and typesetting industry.
</details>

---

![Divider](.github/assets/divider-1.jpg)

### âž¤ Misc

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Blockchain

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Concept</strong></summary>
    Lorem Ipsum is simply dummy text of the printing and typesetting industry.
</details>

![Divider](.github/assets/divider-2.jpg)

<!-- --------------------------------------------------------------------- -->

## Emerging Technologies

<!-- --------------------------------------------------------------------- -->

<details>
    <summary><strong>Concept</strong></summary>
    Lorem Ipsum is simply dummy text of the printing and typesetting industry.
</details>

![Divider](.github/assets/divider-2.jpg)

---

## Stay Updated

For more tech insights, follow me on Twitter X [@Mahmoud_Zalt](https://twitter.com/Mahmoud_Zalt).

## Contributing

We highly appreciate your contributions. For guidance, check our [Contributing Guide](CONTRIBUTING.md).

## License

This repository is licensed under a [CC BY-NC-SA 4.0](LICENSE) Â© [Mahmoud Zalt](https://github.com/Mahmoudz).
